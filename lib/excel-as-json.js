// Generated by CoffeeScript 1.10.0
(function() {
  var BOOLTEXT, BOOLVALS, _, assign, async, convert, convertValue, convertValueList, excel, fs, generateMultipleFile, isArray, math, parseKeyName, path, processFile, write,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs-extra');

  path = require('path');

  async = require('async');

  math = require('mathjs');

  _ = require('lodash');

  excel = require('excel');

  BOOLTEXT = ['true', 'false'];

  BOOLVALS = {
    'true': true,
    'false': false
  };

  isArray = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  parseKeyName = function(key) {
    var index;
    index = key.match(/\[(\d+)\]$/);
    switch (false) {
      case !index:
        return [true, key.split('[')[0], Number(index[1])];
      case key.slice(-2) !== '[]':
        return [true, key.slice(0, -2), void 0];
      default:
        return [false, key, void 0];
    }
  };

  convertValueList = function(list) {
    var item, j, len, results1;
    results1 = [];
    for (j = 0, len = list.length; j < len; j++) {
      item = list[j];
      results1.push(convertValue(item));
    }
    return results1;
  };

  convertValue = function(value) {
    var testVal;
    if (value.length === 0 || !/\S/.test(value)) {
      return value;
    } else if (isFinite(value)) {
      return Number(value);
    } else {
      testVal = value.toLowerCase();
      if (indexOf.call(BOOLTEXT, testVal) >= 0) {
        return BOOLVALS[testVal];
      } else {
        return value;
      }
    }
  };

  assign = function(obj, key, value) {
    var i, index, j, keyIsList, keyName, ref, ref1, ref2;
    if (typeof key !== 'object') {
      key = key.split('.');
    }
    ref = parseKeyName(key.shift()), keyIsList = ref[0], keyName = ref[1], index = ref[2];
    if (key.length) {
      if (keyIsList) {
        if (isArray(obj[keyName])) {
          if (!obj[keyName][index]) {
            for (i = j = ref1 = obj[keyName].length, ref2 = index; ref1 <= ref2 ? j <= ref2 : j >= ref2; i = ref1 <= ref2 ? ++j : --j) {
              obj[keyName].push({});
            }
          }
        } else {
          obj[keyName] = (function() {
            var k, ref3, results1;
            results1 = [];
            for (i = k = 0, ref3 = index; 0 <= ref3 ? k <= ref3 : k >= ref3; i = 0 <= ref3 ? ++k : --k) {
              results1.push({});
            }
            return results1;
          })();
        }
        return assign(obj[keyName][index], key, value);
      } else {
        if (obj[keyName] == null) {
          obj[keyName] = {};
        }
        return assign(obj[keyName], key, value);
      }
    } else {
      if (keyIsList && (index != null)) {
        console.error("WARNING: Unexpected key path terminal containing an indexed list for <" + keyName + ">");
        console.error("WARNING: Indexed arrays indicate a list of objects and should not be the last element in a key path");
        console.error("WARNING: The last element of a key path should be a key name or flat array. E.g. alias, aliases[]");
      }
      if (keyIsList && (index == null)) {
        return obj[keyName] = convertValueList(value.split(';'));
      } else {
        return obj[keyName] = convertValue(value);
      }
    }
  };

  convert = function(data, options) {
    var index, item, j, k, keys, len, len1, matrix, rangeColumns, rangeRows, result, row, rows, size, sizeColumns, sizeRows, value;
    options = options || {};
    matrix = math.matrix(data);
    if (options.skipRows || options.skipColumns) {
      size = matrix.size();
      sizeRows = size[0];
      sizeColumns = size[1];
      rangeRows = math.range(options.skipRows || 0, sizeRows);
      rangeColumns = math.range(options.skipColumns || 0, sizeColumns);
      matrix = matrix.subset(math.index(rangeRows, rangeColumns));
    }
    if (options.isColumnsOriented) {
      matrix = math.transpose(matrix);
    }
    data = matrix._data;
    keys = data[0];
    rows = data.slice(1);
    result = [];
    for (j = 0, len = rows.length; j < len; j++) {
      row = rows[j];
      item = {};
      for (index = k = 0, len1 = row.length; k < len1; index = ++k) {
        value = row[index];
        assign(item, keys[index], value);
      }
      result.push(item);
    }
    return result;
  };

  generateMultipleFile = function(result, options) {
    var data, filenameFromField, fileName, i, j, len, results1, sheetOptions;
    results1 = [];
    for (i = j = 0, len = result.length; j < len; i = ++j) {
      data = result[i];
      if (options.filenameFromField) {
        filenameFromField = options.filenameFromField;
      }
      fileName = data[filenameFromField] + '.json';
      delete data[filenameFromField];
      sheetOptions = _.clone(options);
      sheetOptions.name = fileName;
      results1.push({
        data: data,
        options: sheetOptions
      });
    }
    return results1;
  };

  write = function(data, dst, options, callback) {
    var dir, extName, subfolder;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    extName = path.extname(dst);
    if (extName === '.json') {
      dir = path.dirname(dst);
    } else if (options.name) {
      subfolder = options.subfolder || '/';
      dst = dst + subfolder + options.name;
    } else {
      return callback("Error destination without name of file " + dst);
    }
    dir = path.dirname(dst);
    fs.mkdirsSync(dir);
    return fs.writeFile(dst, JSON.stringify(data, null, 2), function(err) {
      if (err) {
        return callback("Error writing file " + dst + ": " + err);
      } else {
        return callback();
      }
    });
  };

  processFile = function(src, dst, options, callback) {
    var results, sheets;
    if (typeof options === 'function' && typeof callback === 'undefined') {
      callback = options;
      options = {};
    }
    if (!callback) {
      callback = function() {};
    }
    if (!fs.existsSync(src)) {
      return callback("Cannot find src file " + src);
    } else {
      results = [];
      options = options || {};
      sheets = options.sheets;
      delete options.sheets;
      if (sheets) {
        if (typeof sheets === 'number') {
          sheets = [].concat({
            index: sheets
          });
        }
      } else {
        sheets = [].concat({
          index: 1
        });
      }
      return async.eachSeries(sheets, function(sheet, cb) {
        return excel(src, sheet.index, function(err, data) {
          var globalOptions, result, sheetOptions;
          if (err) {
            return cb("Error reading file " + src + ": " + err);
          } else {
            globalOptions = _.clone(options);
            sheetOptions = _.merge(globalOptions, sheet);
            result = convert(data, sheetOptions);
            if (dst) {
              if (sheetOptions.oneFilePerColumn) {
                result = generateMultipleFile(result, sheetOptions);
                return async.eachSeries(result, (function(_this) {
                  return function(r, cbMultipleFiles) {
                    return write(r.data, dst, r.options, function(err) {
                      if (err) {
                        return cbMultipleFiles(err);
                      }
                      results.push(r.data);
                      return cbMultipleFiles();
                    });
                  };
                })(this), cb);
              } else {
                return write(result, dst, sheetOptions, function(err) {
                  if (err) {
                    return cb(err);
                  }
                  results.push(result);
                  return cb();
                });
              }
            } else {
              results.push(result);
              return cb();
            }
          }
        });
      }, function(err) {
        if (err) {
          return callback(err);
        }
        if (results.length === 1) {
          return callback(void 0, results[0]);
        }
        return callback(void 0, results);
      });
    }
  };

  exports.assign = assign;

  exports.convert = convert;

  exports.convertValue = convertValue;

  exports.parseKeyName = parseKeyName;

  exports.processFile = processFile;

}).call(this);
